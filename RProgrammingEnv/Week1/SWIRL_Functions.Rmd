---
title: "R Notebook"
output: html_notebook
---

## Notes from Week1 of the Advanced Programming in R Course

### Swirl Exercise on Functions

```{r}
easy_fun <- function(x){
  x
}

easy_fun("Dat is ja schee")
```
More advanced.... aehemm..
```{r}
my_mean <- function(numbers){
  sum(numbers) / length(numbers)
}

my_mean(c(1,4,5,6,7))
```

When defining Functions standards for attributes should be given

i.e. we write a two function call to check if a certain file exists, and if not we download it, and then we run analysis on the data
```{r}
# Check for file and if not download
data_req <- function(date) {
  if(!file.exists("./data/data_%date%.csv.gz")){
    print("file downloading") #Enter code to download here
  }
}

date_det <- function(date){
  # Call requirements
  require(lubridate)
  
  # Extract Date Details
  day = day(date)
  month = month(date)
  year = year(date)
  ls <- list(day, month, year)
  names(ls) <- c('day', 'month', 'year')
  return(ls)
}
```


```{r}
dat <- date_det(Sys.Date())
dat
```

```{r}
na
```


## Working with the `purr` package





*** 
Swirl work

***


| Functions are one of the fundamental building blocks of the R language. They are small pieces of reusable code that can be treated like any other R object.

...

  |=====                                                                                                                                                                                                                                                                 |   2%

| If you've worked through any other part of this course, you've probably used some functions already. Functions are usually characterized by the name of the function followed by parentheses.

...

  |===========                                                                                                                                                                                                                                                           |   4%

| Let's try using a few basic functions just for fun. The Sys.Date() function returns a string representing today's date. Type Sys.Date() below and see what happens.

> Sys.Date()
[1] "2016-11-04"

| You are amazing!

  |================                                                                                                                                                                                                                                                      |   6%

| Most functions in R return a value. Functions like Sys.Date() return a value based on your computer's environment, while other functions manipulate input data in order to compute a return value.

...

  |=====================                                                                                                                                                                                                                                                 |   8%

| The mean() function takes a vector of numbers as input, and returns the average of all of the numbers in the input vector. Inputs to functions are often called arguments. Providing arguments to a function is also sometimes called passing arguments to that function.
| Arguments you want to pass to a function go inside the function's parentheses. Try passing the argument c(2, 4, 5) to the mean() function.

> mean(c(2,4,5))
[1] 3.666667

| Perseverance, that's the answer.

  |===========================                                                                                                                                                                                                                                           |  10%

| Functions usually take arguments which are variables that the function operates on. For example, the mean() function takes a vector as an argument, like in the case of mean(c(2,6,8)). The mean() function then adds up all of the numbers in the vector and divides that
| sum by the length of the vector.

...

  |================================                                                                                                                                                                                                                                      |  12%

| In the following question you will be asked to modify a script that will appear as soon as you move on from this question. When you have finished modifying the script, save your changes to the script and type submit() and the script will be evaluated. There will be
| some comments in the script that opens up, so be sure to read them!

...

  |=====================================                                                                                                                                                                                                                                 |  14%

| The last R expression to be evaluated in a function will become the return value of that function. We want this function to take one argument, x, and return x without modifying it. Delete the pound sign so that x is returned without any modification. Make sure to save
| your script before you type submit().

> submit()

| Sourcing your script...


| You got it!

  |===========================================                                                                                                                                                                                                                           |  16%

| Now that you've created your first function let's test it! Type: boring_function('My first function!'). If your function works, it should
| just return the string: 'My first function!'

> boring_function("My first function!")
[1] "My first function!"

| You are doing so well!

  |================================================                                                                                                                                                                                                                      |  18%

| Congratulations on writing your first function. By writing functions, you can gain serious insight into how R works. As John Chambers, the
| creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that exists is an object. 2. Everything that happens is a function
| call.

...

  |=====================================================                                                                                                                                                                                                                 |  20%

| If you want to see the source code for any function, just type the function name without any arguments or parentheses. Let's try this out
| with the function you just created. Type: boring_function to view its source code.

> boring_function
function(x) {
  x
}

| You are really on a roll!

  |===========================================================                                                                                                                                                                                                           |  22%

| Time to make a more useful function! We're going to replicate the functionality of the mean() function by creating a function called:
| my_mean(). Remember that to calculate the average of all of the numbers in a vector you find the sum of all the numbers in the vector, and
| then divide that sum by the number of numbers in the vector.

...

  |================================================================                                                                                                                                                                                                      |  24%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Great job!

  |======================================================================                                                                                                                                                                                                |  27%

| Now test out your my_mean() function by finding the mean of the vector c(4, 5, 10).

> my_mean(c(4,5,10))
[1] 6.333333

| Your dedication is inspiring!

  |===========================================================================                                                                                                                                                                                           |  29%

| Next, let's try writing a function with default arguments. You can set default values for a function's arguments, and this can be useful
| if you think someone who uses your function will set a certain argument to the same value most of the time.

...

  |================================================================================                                                                                                                                                                                      |  31%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Excellent job!

  |======================================================================================                                                                                                                                                                                |  33%

| Let's do some testing of the remainder function. Run remainder(5) and see what happens.

> remainder(5)
[1] 1

| You are amazing!

  |===========================================================================================                                                                                                                                                                           |  35%

| Let's take a moment to examine what just happened. You provided one argument to the function, and R matched that argument to 'num' since
| 'num' is the first argument. The default value for 'divisor' is 2, so the function used the default value you provided.

...

  |================================================================================================                                                                                                                                                                      |  37%

| Now let's test the remainder function by providing two arguments. Type: remainder(11, 5) and let's see what happens.

> remainder(11,5)
[1] 1

| Great job!

  |======================================================================================================                                                                                                                                                                |  39%

| Once again, the arguments have been matched appropriately.

...

  |===========================================================================================================                                                                                                                                                           |  41%

| You can also explicitly specify arguments in a function. When you explicitly designate argument values by name, the ordering of the
| arguments becomes unimportant. You can try this out by typing: remainder(divisor = 11, num = 5).

> reaminder(divisor=11, num = 5)
Error: could not find function "reaminder"
> remainder(divisor=11, num = 5)
[1] 5

| You got it right!

  |================================================================================================================                                                                                                                                                      |  43%

| As you can see, there is a significant difference between remainder(11, 5) and remainder(divisor = 11, num = 5)!

...

  |======================================================================================================================                                                                                                                                                |  45%

| R can also partially match arguments. Try typing remainder(4, div = 2) to see this feature in action.

> reamainder(4, div=2)
Error: could not find function "reamainder"
> remainder(4, div=2)
[1] 0

| Perseverance, that's the answer.

  |===========================================================================================================================                                                                                                                                           |  47%

| A word of warning: in general you want to make your code as easy to understand as possible. Switching around the orders of arguments by
| specifying their names or only using partial argument names can be confusing, so use these features with caution!

...

  |================================================================================================================================                                                                                                                                      |  49%

| With all of this talk about arguments, you may be wondering if there is a way you can see a function's arguments (besides looking at the
| documentation). Thankfully, you can use the args() function! Type: args(remainder) to examine the arguments for the remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| You nailed it! Good job!

  |======================================================================================================================================                                                                                                                                |  51%

| You may not realize it but I just tricked you into doing something pretty interesting! args() is a function, remainder() is a function,
| yet remainder was an argument for args(). Yes it's true: you can pass functions as arguments! This is a very powerful concept. Let's write
| a script to see how it works.

...

  |===========================================================================================================================================                                                                                                                           |  53%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Perseverance, that's the answer.

  |================================================================================================================================================                                                                                                                      |  55%

| Let's take your new evaluate() function for a spin! Use evaluate to find the standard deviation of the vector c(1.4, 3.6, 7.9, 8.8).

> evaluate(std, c(1.4, 3.6, 7.9, 8.8))
Error in evaluate(std, c(1.4, 3.6, 7.9, 8.8)) : object 'std' not found
> evaluate(std(), c(1.4, 3.6, 7.9, 8.8))
Error in evaluate(std(), c(1.4, 3.6, 7.9, 8.8)) : 
  could not find function "std"
> evaluate(sd(), c(1.4, 3.6, 7.9, 8.8))
 Show Traceback
 
 Rerun with Debug
 Error in is.data.frame(x) : argument "x" is missing, with no default > evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
[1] 3.514138

| That's the answer I was looking for.

  |======================================================================================================================================================                                                                                                                |  57%

| The idea of passing functions as arguments to other functions is an important and fundamental concept in programming.

...

  |===========================================================================================================================================================                                                                                                           |  59%

| You may be surprised to learn that you can pass a function as an argument without first defining the passed function. Functions that are
| not named are appropriately known as anonymous functions.

...

  |================================================================================================================================================================                                                                                                      |  61%

| Let's use the evaluate function to explore how anonymous functions work. For the first argument of the evaluate function we're going to
| write a tiny function that fits on one line. In the second argument we'll pass some data to the tiny anonymous function in the first
| argument.

...

  |======================================================================================================================================================================                                                                                                |  63%

| Type the following command and then we'll discuss how it works: evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| You nailed it! Good job!

  |===========================================================================================================================================================================                                                                                           |  65%

| The first argument is a tiny anonymous function that takes one argument `x` and returns `x+1`. We passed the number 6 into this function
| so the entire expression evaluates to 7.

...

  |================================================================================================================================================================================                                                                                      |  67%

| Try using evaluate() along with an anonymous function to return the first element of the vector c(8, 4, 0). Your anonymous function should
| only take one argument which should be a variable `x`.

> evaluate(function(x[1]), c(8,4,0))
Error: unexpected '[' in "evaluate(function(x["
> evaluate(function(x){x[1]}, c(8,4,0))
[1] 8

| You are doing so well!

  |======================================================================================================================================================================================                                                                                |  69%

| Now try using evaluate() along with an anonymous function to return the last element of the vector c(8, 4, 0). Your anonymous function
| should only take one argument which should be a variable `x`.

> evaluate(function(x){x[-1]}, c(8,4,0))
[1] 4 0

| You're the best!

  |===========================================================================================================================================================================================                                                                           |  71%

| For the rest of the course we're going to use the paste() function frequently. Type ?paste so we can take a look at the documentation for
| the paste function.

> evaluate(function(x){x[-]}, c(8,4,0))
Error: unexpected ']' in "evaluate(function(x){x[-]"
> evaluate(function(x){x[,-]}, c(8,4,0))
Error: unexpected ']' in "evaluate(function(x){x[,-]"
> evaluate(function(x){x[length(x)]}, c(8,4,0))
[1] 0

| Not quite right, but keep trying. Or, type info() for more options.

| Just type: ?paste

> ?paste

| All that hard work is paying off!

  |================================================================================================================================================================================================                                                                      |  73%

| As you can see the first argument of paste() is `...` which is referred to as an ellipsis or simply dot-dot-dot. The ellipsis allows an
| indefinite number of arguments to be passed into a function. In the case of paste() any number of strings can be passed as arguments and
| paste() will return all of the strings combined into one string.

...

  |======================================================================================================================================================================================================                                                                |  76%

| Just to see how paste() works, type paste("Programming", "is", "fun!")

> paste("Programming", "is", "fun!")
[1] "Programming is fun!"

| You are really on a roll!

  |===========================================================================================================================================================================================================                                                           |  78%

| Time to write our own modified version of paste().

...

  |=================================================================================================================================================================================================================                                                     |  80%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Keep up the great work!

  |======================================================================================================================================================================================================================                                                |  82%

| Now let's test out your telegram function. Use your new telegram function passing in whatever arguments you wish!

> 
> telegram("Hello there", "i am coming home", "but not before christmas!")
[1] "START Hello there i am coming home but not before christmas! STOP"

| Keep up the great work!

  |===========================================================================================================================================================================================================================                                           |  84%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway!

| Your function should have three sections: capture the ellipsis in a list(), unpack the arguments from the ellipsis and assign them to
| variables, then pass those variables to paste().

> submit()

| Sourcing your script...


| Perseverance, that's the answer.

  |=================================================================================================================================================================================================================================                                     |  86%

| Time to use your mad_libs function. Make sure to name the place, adjective, and noun arguments in order for your function to work.

> mad_libs("New Zork", "happy", "Camper")
[1] "News from  today where  students took to the streets in protest of the new  being installed on campus."

| All that hard work is paying off!

  |======================================================================================================================================================================================================================================                                |  88%

| We're coming to the end of this lesson, but there's still one more idea you should be made aware of.

...

  |===========================================================================================================================================================================================================================================                           |  90%

| You're familiar with adding, subtracting, multiplying, and dividing numbers in R. To do this you use the +, -, *, and / symbols. These
| symbols are called binary operators because they take two inputs, an input from the left and an input from the right.

...

  |=================================================================================================================================================================================================================================================                     |  92%

| In R you can define your own binary operators. In the next script I'll show you how.

...

  |======================================================================================================================================================================================================================================================                |  94%

| Make sure to save your script before you type submit().

> submit
function () 
{
    invisible()
}
<environment: namespace:swirl>
> submit()

| Sourcing your script...


| Excellent job!

  |===========================================================================================================================================================================================================================================================           |  96%

| You made your own binary operator! Let's test it out. Paste together the strings: 'I', 'love', 'R!' using your new binary operator.

> "I" %p% "love" %p% "R!"
[1] "I love R!"

| That's a job well done!

  |=================================================================================================================================================================================================================================================================     |  98%

| We've come to the end of our lesson! Go out there and write some great functions!

...

  |======================================================================================================================================================================================================================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes
3: Generate Code

Selection: 2
What is your email address? frank.fichtenmueller@outlook.com
What is your assignment token? 9h2frMCv2RzNbiwO
Grade submission succeeded!

| Excellent job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: Advanced R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

1: Setting Up Swirl
2: Functions
3: Functional Programming with purrr

Selection: 3

| Attempting to load lesson dependencies...

| Package 'purrr' loaded correctly!

  |                                                                                                                                   |   0%

| Functional programming is a programming philosophy based on lambda calculus. Lambda calculus was created by Alonzo Church, the PhD adviser
| to Alan Turing who is known for his role in cracking the encryption of the Nazi's Enigma machine during World War Two. Functional
| programming has been a popular approach ever since it helped bring down the Third Reich.

...

  |===                                                                                                                                |   3%

| Functional programming concentrates on four constructs - Data (numbers, strings, etc), Variables (function arguments), Functions, and
| Function Applications (evaluating functions given arguments and/or data).

...

  |=======                                                                                                                            |   5%

| There are groups of functions that are essential for functional programming. In most cases they take a function and a data structure as
| arguments, and that function is applied to that data structure in some way. The purrr library contains many of these functions and we'll
| be using it throughout this lesson. Functional programming is concerned mostly with lists and vectors. I may refer to just lists or
| vectors, but you should know that what applies for lists generally applies for vectors and vice-versa.

...

  |==========                                                                                                                         |   8%

| I have defined a few functions that we are going to use throughout this lesson. Take a moment to familarize yourself with the
| documentation for these functions.

...

  |=============                                                                                                                      |  10%

| The first family of functions we'll be discussing are the Map functions.

...

  |=================                                                                                                                  |  13%

| The map family of functions applies a function to the elements of a data structure, usually a list or a vector. The function is evaluated
| once for each element of the vector with the vector element as the first argument to the function. The return value is the same kind if
| data structure (a list or vector) but with every element replaced by the result of the function being evaluated with the corresponding
| element as the argument to the function.

...

  |====================                                                                                                               |  15%

| In the purrr package the map() function returns a list, while the map_lgl(), map_chr(), and map_dbl() functions return vectors of logical
| values, strings, or numbers respectively.

...

  |========================                                                                                                           |  18%

| Enter map_chr(c(5, 3, 4), int_to_string) into the R console to map the int_to_string() function to the vector c(5, 3, 4).

> map_chr(c(5,3,4), int_to_string)
[1] "five"  "three" "four" 

| That's correct!

  |===========================                                                                                                        |  21%

| Think about evaluating the int_to_string() function with just one of the arguments in the specified numeric vector, and then combining all
| of those function results into one vector. That's essentially how the map functions work!

...

  |==============================                                                                                                     |  23%

| Let's try using a function that has two arguments with a map function. Use map_lgl() to map the function gt() to vector c(1, 2, 3, 4, 5)
| to see which elements of that vector are greater than 3. Make sure to specify the last argument of map_lgl() as b = 3.

> map_lgl(c(1,2,3,4,5), gt())
Error in gt() : argument "a" is missing, with no default
> map_lgl(c(1,2,3,4,5), gt(b=3))
Error in gt(b = 3) : argument "a" is missing, with no default
> map_lgl(gt(b=3),c(1,2,3,4,5))
Error in gt(b = 3) : argument "a" is missing, with no default
> map_lgl(.x = c(1,2,3,4,5), .f = gt, b=3)
[1] FALSE FALSE FALSE  TRUE  TRUE

| You got it right!

  |==================================                                                                                                 |  26%

| The map_if() function takes as its arguments a list or vector containing data, a predicate function, and then a function to be applied.

...

  |=====================================                                                                                              |  28%

| A predicate function is a function that returns TRUE or FALSE for each element in the provided list or vector. In the case of map_if(): if
| the predicate functions evaluates to TRUE, then the function is applied to the corresponding vector element, however if the predicate
| function evaluates to FALSE then the function is not applied.

...

  |========================================                                                                                           |  31%

| Use map_if() to map square() to the even elements of the vector c(1, 2, 3, 4). Use the is_even() function as a predicate.

> map_if(c(1,2,3,4), is_even, square)
[[1]]
[1] 1

[[2]]
[1] 4

[[3]]
[1] 3

[[4]]
[1] 16


| That's a job well done!

  |============================================                                                                                       |  33%

| Take a look at the output - all of the even numbers were squared while the odd numbers were left alone! Notice that the map_if() function
| always returns a list.

...

  |===============================================                                                                                    |  36%

| The map_at() function only applies the provided function to elements of a vector specified by their indexes. Like map_if(), map_at()
| always returns a list.

...

  |==================================================                                                                                 |  38%

| Use the map_at() function to map square() to the first, third, and fourth element of the vector c(4, 6, 2, 3, 8).

> map_at(c(4,6,2,3,8), c(1,3,4), square)
[[1]]
[1] 16

[[2]]
[1] 6

[[3]]
[1] 4

[[4]]
[1] 9

[[5]]
[1] 8


| You are quite good my friend!

  |======================================================                                                                             |  41%

| In each of the previous examples we have only been mapping a function over one data structure, however you can map a function over two
| data structures with the map2() family of functions. The first two arguments should be two vectors of the same length, followed by a
| function which will be evaluated with an element of the first vector as the first argument and an element of the second vector as the
| second argument.

...

  |=========================================================                                                                          |  44%

| Use map2_chr() to apply the paste() function to the sequence of integers from 1 to 26 and all the letters of the alphabet in lowercase.

> map2_chr(1:26, letters, paste)
 [1] "1 a"  "2 b"  "3 c"  "4 d"  "5 e"  "6 f"  "7 g"  "8 h"  "9 i"  "10 j" "11 k" "12 l" "13 m" "14 n" "15 o" "16 p" "17 q" "18 r" "19 s"
[20] "20 t" "21 u" "22 v" "23 w" "24 x" "25 y" "26 z"

| Give it another try. Or, type info() for more options.

| Just type map2_chr(letters, 1:26, paste)

> map2_chr(letters,1:26, paste)
 [1] "a 1"  "b 2"  "c 3"  "d 4"  "e 5"  "f 6"  "g 7"  "h 8"  "i 9"  "j 10" "k 11" "l 12" "m 13" "n 14" "o 15" "p 16" "q 17" "r 18" "s 19"
[20] "t 20" "u 21" "v 22" "w 23" "x 24" "y 25" "z 26"

| Keep up the great work!

  |============================================================                                                                       |  46%

| Now we'll discuss the Reduce family of functions.

...

  |================================================================                                                                   |  49%

| List or vector reduction iteratively combines the first element of a vector with the second element of a vector, then that combined result
| is combined with the third element of the vector, and so on until the end of the vector is reached. The function to be applied should take
| at least two arguments. Where mapping returns a vector or a list, reducing should return a single value.

...

  |===================================================================                                                                |  51%

| Reduce the vector c(1, 3, 5, 7) with the function add_talk() using the reduce() function.

> reduce(c(1,3,5,7), add_talk)
x is 1
y is 3

x is 4
y is 5

x is 9
y is 7

[1] 16

| That's the answer I was looking for.

  |=======================================================================                                                            |  54%

| On the first iteration x has the value 1 and y has the value 3, then the two values are combined (they're added together). On the second
| iteration x has the value of the result from the first iteration (4) and y has the value of the third element in the provided numeric
| vector (5). This process is repeated for each iteration.

...

  |==========================================================================                                                         |  56%

| Reduce the vector c("a", "b", "c", "d") into one string using the paste_talk() function and the reduce() function.

> reduce(c("a", "b", "c", "d"), paste_talk)
x is a
y is b

x is ab
y is c

x is abc
y is d

[1] "abcd"

| You are amazing!

  |=============================================================================                                                      |  59%

| By default reduce() starts with the first element of a vector and then the second element and so on. In contrast the reduce_right()
| function starts with the last element of a vector and then proceeds to the second to last element of a vector and so on.

...

  |=================================================================================                                                  |  62%

| Reduce the vector c("a", "b", "c", "d") into one string using the paste_talk() function and the reduce_right() function.

> reduce_right(c('a', 'b', 'c', 'd'), paste_talk)
x is d
y is c

x is dc
y is b

x is dcb
y is a

[1] "dcba"

| You are quite good my friend!

  |====================================================================================                                               |  64%

| Next we'll discuss fuctions for searching a list or a vector.

...

  |=======================================================================================                                            |  67%

| You can search for specific elements of a vector using the contains() and detect() functions. contains() will return TRUE if a specified
| element is present in a vector, otherwise it returns FALSE.

...

  |===========================================================================================                                        |  69%

| Use the contains() function to see if the vector random_ints contains the number 45.

> contains(45, random_ints)
[1] FALSE

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Just enter contains(random_ints, 45)

> contains(random_ints, 45)
[1] TRUE

| That's correct!

  |==============================================================================================                                     |  72%

| The detect() function takes a vector and a predicate function as arguments and it returns the first element of the vector for which the
| predicate function returns TRUE. Use detect() and is_even() to find the first element of random_ints that is an even number.

> detect(random_ints, is_even)
[1] 10

| Great job!

  |=================================================================================================                                  |  74%

| The detect_index() function takes the same arguments as detect(), however it returns the index of the provided vector which contains the
| first element that satisfies the predicate function. Use detect_index() and is_even() to find the index of the first element of
| random_ints that is an even number.

> detect_index(random_ints, is_even)
[1] 3

| All that practice is paying off!

  |=====================================================================================================                              |  77%

| The group of functions that includes keep(), discard(), every(), and some() are known as filter functions. Each of these functions takes a
| vector and a predicate function as arguments.

...

  |========================================================================================================                           |  79%

| For keep() only the elements of the vector that satisfy the predicate function are returned while all other elements are removed. Use the
| keep() function with random_ints and is_even() to extract the even elements of random_ints.

> keep(random_ints, is_even)
[1] 10  6  8

| Your dedication is inspiring!

  |===========================================================================================================                        |  82%

| The discard() function works similarly, it only returns elements that don't satisfy the predicate function. Use discard() to
| filter out the even elements of random_ints.

> discard(random_ints, is_even)
 [1]  89  59  27  69  31  91  29  73  55  39  85  33  43  25  87  35  83  97  71  81  75  23  49  65  99  47  37  79  95  57  41
[32]  77  63  67  51  53 101  45  61  21  93

| Keep working like that and you'll get there!

  |===============================================================================================================                    |  85%

| The every() function returns TRUE only if every element in the vector satisfies the predicate function, while the some()
| function returns TRUE if at least one element in the vector satisfies the predicate function. Use every() to see if every
| value of random_ints is less than 100.

> every(random_ints, < 100)
Error: unexpected '<' in "every(random_ints, <"
> every(random_ints < 100)
Error in as_function(.p, ...) : argument ".p" is missing, with no default
> every(random_ints, random_ints < 100)
Error: Don't know how to convert logical into a function
> every(random_ints, '< 100')
[1] FALSE

| You are quite good my friend!

  |==================================================================================================================                 |  87%

| Finally let's talk about two functions - partial() and walk().

...

  |======================================================================================================================             |  90%

| Partial application of functions can allow functions to behave a little like data structures. Using the partial() function
| from the purrr package you can specify some of the arguments of a function, and then partial() will return a function that
| only takes the unspecified arguments. Use partial() to create a new function caled gt_10 which returns TRUE if its only
| argument is greater than ten and FALSE otherwise.

> partial(gt_10, "> 10")
Error in stopifnot(is.function(...f)) : object 'gt_10' not found
> partial(...f = gt_10, ... = "> 10")
Error in stopifnot(is.function(...f)) : object 'gt_10' not found
> partial(...f = gt_10(), ... = "> 10")
Error in stopifnot(is.function(...f)) : could not find function "gt_10"
> gt_10 <- partial(x,"> 10")
Error: is.function(...f) is not TRUE
> gt_10 <- partial(gt(10))
Error in gt(10) : argument "b" is missing, with no default
> skip()

| Entering the following correct answer for you...

> gt_10 <- partial(gt, b = 10)

| You are amazing!

  |=========================================================================================================================          |  92%

| Now test the new function out by entering gt_10(11) into the console.

> gt_10(11)
[1] TRUE

| All that practice is paying off!

  |============================================================================================================================       |  95%

| Side effects of functions occur whenever a function interacts with the "outside world" - reading or writing data, printing to
| the console, and displaying a graph are all side effects. The results of side effects are one of the main motivations for
| writing code in the first place! Side effects can be tricky to handle though, since the order in which functions with side
| effects are executed often matters and there are variables that are external to the program (the relative location of some
| data).

...

  |================================================================================================================================   |  97%

| If you want to evaluate a function across a data structure you should use the walk() function from purrr. Use walk() across
| the vector called mark_antony with the message function.

> walk(mark_antony, message)
Friends, Romans, countrymen,
lend me your ears;
I come to bury Caesar,
not to praise him.

| You got it!

  |===================================================================================================================================| 100%
